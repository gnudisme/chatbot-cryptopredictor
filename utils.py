import re
import json
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)

def format_price(price: float, decimals: int = None) -> str:
    """Format gi√° ti·ªÅn v·ªõi s·ªë th·∫≠p ph√¢n ph√π h·ª£p"""
    try:
        if price is None:
            return "N/A"
        
        if decimals is None:
            # T·ª± ƒë·ªông x√°c ƒë·ªãnh s·ªë th·∫≠p ph√¢n
            if price >= 1000:
                decimals = 2
            elif price >= 1:
                decimals = 4
            elif price >= 0.01:
                decimals = 6
            else:
                decimals = 8
        
        formatted = f"{price:,.{decimals}f}"
        
        # Lo·∫°i b·ªè s·ªë 0 th·ª´a ·ªü cu·ªëi
        if '.' in formatted:
            formatted = formatted.rstrip('0').rstrip('.')
        
        return formatted
        
    except Exception as e:
        logger.error(f"L·ªói format price: {e}")
        return str(price)

def format_percentage(percentage: float, decimals: int = 2) -> str:
    """Format ph·∫ßn trƒÉm v·ªõi m√†u s·∫Øc emoji"""
    try:
        if percentage is None:
            return "N/A"
        
        formatted = f"{percentage:+.{decimals}f}%"
        
        # Th√™m emoji
        if percentage > 0:
            return f"üü¢ {formatted}"
        elif percentage < 0:
            return f"üî¥ {formatted}"
        else:
            return f"‚ö™ {formatted}"
            
    except Exception as e:
        logger.error(f"L·ªói format percentage: {e}")
        return str(percentage)

def format_volume(volume: float) -> str:
    """Format volume v·ªõi ƒë∆°n v·ªã ph√π h·ª£p"""
    try:
        if volume is None:
            return "N/A"
        
        if volume >= 1_000_000_000:
            return f"{volume/1_000_000_000:.2f}B"
        elif volume >= 1_000_000:
            return f"{volume/1_000_000:.2f}M"
        elif volume >= 1_000:
            return f"{volume/1_000:.2f}K"
        else:
            return f"{volume:.2f}"
            
    except Exception as e:
        logger.error(f"L·ªói format volume: {e}")
        return str(volume)

def format_market_cap(market_cap: float) -> str:
    """Format market cap"""
    try:
        if market_cap is None:
            return "N/A"
        
        if market_cap >= 1_000_000_000_000:
            return f"${market_cap/1_000_000_000_000:.2f}T"
        elif market_cap >= 1_000_000_000:
            return f"${market_cap/1_000_000_000:.2f}B"
        elif market_cap >= 1_000_000:
            return f"${market_cap/1_000_000:.2f}M"
        else:
            return f"${market_cap:,.0f}"
            
    except Exception as e:
        logger.error(f"L·ªói format market cap: {e}")
        return str(market_cap)

def format_time_ago(timestamp: str) -> str:
    """Format th·ªùi gian th√†nh 'x ph√∫t/gi·ªù/ng√†y tr∆∞·ªõc'"""
    try:
        if not timestamp:
            return "N/A"
        
        # Parse timestamp
        if isinstance(timestamp, str):
            # X·ª≠ l√Ω c√°c format timestamp kh√°c nhau
            if 'T' in timestamp:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
            else:
                dt = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
        else:
            dt = timestamp
        
        now = datetime.now(dt.tzinfo) if dt.tzinfo else datetime.now()
        diff = now - dt
        
        if diff.days > 0:
            return f"{diff.days} ng√†y tr∆∞·ªõc"
        elif diff.seconds >= 3600:
            hours = diff.seconds // 3600
            return f"{hours} gi·ªù tr∆∞·ªõc"
        elif diff.seconds >= 60:
            minutes = diff.seconds // 60
            return f"{minutes} ph√∫t tr∆∞·ªõc"
        else:
            return "V·ª´a xong"
            
    except Exception as e:
        logger.error(f"L·ªói format time ago: {e}")
        return "N/A"

def validate_symbol(symbol: str) -> str:
    """Validate v√† chu·∫©n h√≥a symbol"""
    try:
        if not symbol:
            return None
        
        symbol = symbol.upper().strip()
        
        # Lo·∫°i b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
        symbol = re.sub(r'[^A-Z0-9]', '', symbol)
        
        # Th√™m USDT n·∫øu ch∆∞a c√≥
        if not symbol.endswith('USDT') and len(symbol) <= 10:
            symbol += 'USDT'
        
        return symbol
        
    except Exception as e:
        logger.error(f"L·ªói validate symbol: {e}")
        return None

def calculate_rsi(prices: List[float], period: int = 14) -> float:
    """T√≠nh RSI"""
    try:
        if len(prices) < period + 1:
            return 50  # Gi√° tr·ªã m·∫∑c ƒë·ªãnh
        
        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        avg_gain = np.mean(gains[-period:])
        avg_loss = np.mean(losses[-period:])
        
        if avg_loss == 0:
            return 100
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
        
    except Exception as e:
        logger.error(f"L·ªói t√≠nh RSI: {e}")
        return 50

def calculate_sma(prices: List[float], period: int) -> float:
    """T√≠nh Simple Moving Average"""
    try:
        if len(prices) < period:
            return np.mean(prices) if prices else 0
        
        return np.mean(prices[-period:])
        
    except Exception as e:
        logger.error(f"L·ªói t√≠nh SMA: {e}")
        return 0

def calculate_ema(prices: List[float], period: int) -> float:
    """T√≠nh Exponential Moving Average"""
    try:
        if len(prices) < period:
            return np.mean(prices) if prices else 0
        
        multiplier = 2 / (period + 1)
        ema = prices[0]
        
        for price in prices[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        
        return ema
        
    except Exception as e:
        logger.error(f"L·ªói t√≠nh EMA: {e}")
        return 0

def get_support_resistance(prices: List[float], window: int = 20) -> Dict[str, float]:
    """T√≠nh support v√† resistance levels"""
    try:
        if len(prices) < window:
            return {'support': min(prices), 'resistance': max(prices)}
        
        recent_prices = prices[-window:]
        support = min(recent_prices)
        resistance = max(recent_prices)
        
        return {'support': support, 'resistance': resistance}
        
    except Exception as e:
        logger.error(f"L·ªói t√≠nh support/resistance: {e}")
        return {'support': 0, 'resistance': 0}

def calculate_volatility(prices: List[float], period: int = 20) -> float:
    """T√≠nh volatility (ƒë·ªô bi·∫øn ƒë·ªông)"""
    try:
        if len(prices) < period:
            return 0
        
        recent_prices = prices[-period:]
        returns = np.diff(recent_prices) / recent_prices[:-1]
        volatility = np.std(returns) * 100  # Chuy·ªÉn th√†nh %
        
        return volatility
        
    except Exception as e:
        logger.error(f"L·ªói t√≠nh volatility: {e}")
        return 0

def get_trend_direction(prices: List[float], short_period: int = 7, long_period: int = 25) -> str:
    """X√°c ƒë·ªãnh h∆∞·ªõng trend"""
    try:
        if len(prices) < long_period:
            return "Kh√¥ng ƒë·ªß d·ªØ li·ªáu"
        
        short_sma = calculate_sma(prices, short_period)
        long_sma = calculate_sma(prices, long_period)
        
        if short_sma > long_sma:
            return "TƒÉng üìà"
        elif short_sma < long_sma:
            return "Gi·∫£m üìâ"
        else:
            return "Sideway ‚û°Ô∏è"
            
    except Exception as e:
        logger.error(f"L·ªói x√°c ƒë·ªãnh trend: {e}")
        return "N/A"

def generate_trading_signal(rsi: float, macd: float, price: float, sma: float) -> Dict[str, Any]:
    """T·∫°o t√≠n hi·ªáu trading"""
    try:
        signals = []
        overall_signal = "HOLD"
        confidence = 50
        
        # RSI signals
        if rsi > 70:
            signals.append("RSI qu√° mua")
            confidence -= 10
        elif rsi < 30:
            signals.append("RSI qu√° b√°n")
            confidence += 10
        
        # MACD signals
        if macd > 0:
            signals.append("MACD t√≠ch c·ª±c")
            confidence += 5
        else:
            signals.append("MACD ti√™u c·ª±c")
            confidence -= 5
        
        # Price vs SMA
        if price > sma:
            signals.append("Gi√° tr√™n SMA")
            confidence += 5
        else:
            signals.append("Gi√° d∆∞·ªõi SMA")
            confidence -= 5
        
        # T·ªïng h·ª£p signal
        if confidence > 70:
            overall_signal = "BUY"
        elif confidence < 30:
            overall_signal = "SELL"
        
        return {
            'signal': overall_signal,
            'confidence': max(0, min(100, confidence)),
            'signals': signals
        }
        
    except Exception as e:
        logger.error(f"L·ªói t·∫°o trading signal: {e}")
        return {'signal': 'HOLD', 'confidence': 50, 'signals': []}

def clean_text(text: str) -> str:
    """L√†m s·∫°ch text cho Telegram"""
    try:
        if not text:
            return ""
        
        # Lo·∫°i b·ªè HTML tags
        text = re.sub(r'<[^>]+>', '', text)
        
        # Lo·∫°i b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát c·ªßa Markdown
        text = text.replace('*', '\\*')
        text = text.replace('_', '\\_')
        text = text.replace('[', '\\[')
        text = text.replace(']', '\\]')
        text = text.replace('(', '\\(')
        text = text.replace(')', '\\)')
        text = text.replace('`', '\\`')
        
        return text.strip()
        
    except Exception as e:
        logger.error(f"L·ªói clean text: {e}")
        return str(text)

def truncate_text(text: str, max_length: int = 100) -> str:
    """C·∫Øt ng·∫Øn text"""
    try:
        if not text or len(text) <= max_length:
            return text
        
        return text[:max_length-3] + "..."
        
    except Exception as e:
        logger.error(f"L·ªói truncate text: {e}")
        return str(text)

def save_user_preferences(user_id: int, preferences: Dict[str, Any]) -> bool:
    """L∆∞u preferences c·ªßa user"""
    try:
        filename = f"user_preferences_{user_id}.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(preferences, f, ensure_ascii=False, indent=2)
        return True
        
    except Exception as e:
        logger.error(f"L·ªói l∆∞u user preferences: {e}")
        return False

def load_user_preferences(user_id: int) -> Dict[str, Any]:
    """Load preferences c·ªßa user"""
    try:
        filename = f"user_preferences_{user_id}.json"
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)
            
    except FileNotFoundError:
        # Tr·∫£ v·ªÅ preferences m·∫∑c ƒë·ªãnh
        return {
            'favorite_coins': ['BTCUSDT', 'ETHUSDT'],
            'notifications': True,
            'language': 'vi',
            'timezone': 'Asia/Ho_Chi_Minh'
        }
    except Exception as e:
        logger.error(f"L·ªói load user preferences: {e}")
        return {}

def format_coin_info(coin_data: Dict[str, Any]) -> str:
    """Format th√¥ng tin coin th√†nh text ƒë·∫πp"""
    try:
        text = f"üìä *{coin_data.get('symbol', 'N/A')}*\n\n"
        
        if 'price' in coin_data:
            text += f"üí∞ Gi√°: ${format_price(coin_data['price'])}\n"
        
        if 'change_percent' in coin_data:
            text += f"üìà 24h: {format_percentage(coin_data['change_percent'])}\n"
        
        if 'volume' in coin_data:
            text += f"üìä Volume: {format_volume(coin_data['volume'])}\n"
        
        if 'market_cap' in coin_data:
            text += f"üè¶ Market Cap: {format_market_cap(coin_data['market_cap'])}\n"
        
        if 'high' in coin_data and 'low' in coin_data:
            text += f"üìä 24h High/Low: ${format_price(coin_data['high'])} / ${format_price(coin_data['low'])}\n"
        
        return text
        
    except Exception as e:
        logger.error(f"L·ªói format coin info: {e}")
        return "L·ªói hi·ªÉn th·ªã th√¥ng tin"

def get_emoji_for_change(change_percent: float) -> str:
    """L·∫•y emoji ph√π h·ª£p cho % thay ƒë·ªïi"""
    try:
        if change_percent > 10:
            return "üöÄ"
        elif change_percent > 5:
            return "üìà"
        elif change_percent > 0:
            return "üü¢"
        elif change_percent == 0:
            return "‚ö™"
        elif change_percent > -5:
            return "üî¥"
        elif change_percent > -10:
            return "üìâ"
        else:
            return "üí•"
            
    except Exception as e:
        logger.error(f"L·ªói get emoji: {e}")
        return "‚ö™"